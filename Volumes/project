def func_call(self, args):
    name_node = args[0]

    # Extract passed arguments
    passed_args = []
    if len(args) > 1 and isinstance(args[1], Tree) and args[1].data == "args":
        passed_args = [self.eval_arg(a) for a in args[1].children]

    # Handle dotted calls (module.method)
    if isinstance(name_node, Tree) and name_node.data == "dotted_name":
        module, method = [str(t) for t in name_node.children][:2]

        # Check native calls explicitly first
        native_name = f"{module}.{method}"
        if native_name in self.native:
            print(f"[DEBUG] Calling native module '{native_name}' with args {passed_args}")
            return self.native[native_name](*passed_args)

        # Module-based functions
        if module in self.modules:
            mod = self.modules[moduledef func_call(self, args):
                name_node = args[0]
                # Extract passed arguments
                passed_args = []
                if len(args) > 1 and isinstance(args[1], Tree) and args[1].data == "args":
                    passed_args = [self.eval_arg(a) for a in args[1].children]
            
                # Handle dotted calls (module.method)
                if isinstance(name_node, Tree) and name_node.data == "dotted_name":
                    name_parts = [str(t.value) if isinstance(t, Token) else str(t) for t in name_node.children]
                    obj_name, method_name = name_parts[0], name_parts[1]
            
                    # Resolve from self.modules
                    if obj_name in self.modules:
                        obj = self.modules[obj_name]
                        print(f"[DEBUG] Found {obj_name} in self.modules: {type(obj)}")
            
                        # Attribute access (object-style)
                        if hasattr(obj, method_name):
                            attr = getattr(obj, method_name)
                            print(f"[DEBUG] {obj_name}.{method_name} resolved via attribute: {attr} (callable={callable(attr)})")
                            if callable(attr):
                                return attr(*passed_args)
                            else:
                                raise TypeError(f"Attribute '{method_name}' of module '{obj_name}' is not callable")
                        # Dict-style access
                        elif isinstance(obj, dict) and method_name in obj:
                            func = obj[method_name]
                            print(f"[DEBUG] {obj_name}.{method_name} resolved via dict key: {func} (callable={callable(func)})")
                            if callable(func):
                                return func(*passed_args)
                            else:
                                raise TypeError(f"Key '{method_name}' of module '{obj_name}' is not callable")
                        else:
                            raise AttributeError(f"Module '{obj_name}' has no method or key '{method_name}'")
                    # Optionally: fallback to self.native if present
                    elif hasattr(self, "native") and obj_name in getattr(self, "native", {}):
                        native_obj = self.native[obj_name]
                        print(f"[DEBUG] Fallback: Found {obj_name} in self.native: {type(native_obj)}")
                        if hasattr(native_obj, method_name):
                            attr = getattr(native_obj, method_name)
                            print(f"[DEBUG] {obj_name}.{method_name} (native) resolved via attribute: {attr} (callable={callable(attr)})")
                            if callable(attr):
                                return attr(*passed_args)
                            else:
                                raise TypeError(f"Attribute '{method_name}' of native module '{obj_name}' is not callable")
                        elif isinstance(native_obj, dict) and method_name in native_obj:
                            func = native_obj[method_name]
                            print(f"[DEBUG] {obj_name}.{method_name} (native) resolved via dict key: {func} (callable={callable(func)})")
                            if callable(func):
                                return func(*passed_args)
                            else:
                                raise TypeError(f"Key '{method_name}' of native module '{obj_name}' is not callable")
                        else:
                            raise AttributeError(f"Native module '{obj_name}' has no method or key '{method_name}'")
                    else:
                        raise NameError(f"Module '{obj_name}' not imported")
            
                # Handle user-defined function calls
                name = str(name_node)
                if name not in self.functions:
                    raise NameError(f"Function '{name}' not defined")
            
                params, body = self.functions[name]
                if len(params) != len(passed_args):
                    raise ValueError(f"Function '{name}' expects {len(params)} arguments, got {len(passed_args)}")
            
                self.push_scope()
                for pname, pval in zip(params, passed_args):
                    self.set_var(pname, pval)
            
                try:
                    self._exec(body.children)
                except ReturnSignal as r:
                    self.pop_scope()
                    return r.value]
         
            if isinstance(mod, dict):
                if method in mod:
                    print(f"[DEBUG] Calling dict module '{module}.{method}' with args {passed_args}")
                    return mod[method](*passed_args)
                else:
                    raise AttributeError(f"Dict module '{module}' has no key '{method}'")

            # Handle real Python modules
            elif hasattr(mod, method):
                func = getattr(mod, method)
                print(f"[DEBUG] Calling native module '{module}.{method}' with args {passed_args}")
                return func(*passed_args)

            else:
                raise AttributeError(f"Module '{module}' has no method '{method}'")

    # Handle user-defined function calls
    name = str(name_node)
    if name not in self.functions:
        raise NameError(f"Function '{name}' not defined")

    params, body = self.functions[name]
    if len(params) != len(passed_args):
        raise ValueError(f"Function '{name}' expects {len(params)} arguments, got {len(passed_args)}")

    self.push_scope()
    for pname, pval in zip(params, passed_args):
        self.set_var(pname, pval)

    try:
        self._exec(body.children)
    except ReturnSignal as r:
        self.pop_scope()
        return r.value

self.modules["stdin"] = {
    "input": native_io.stdin_input,
    "read": native_io.stdin_read_file,
    "write": native_io.stdin_write,
    "append": native_io.stdin_append,
    "write_file": native_io.stdin_write_file,
    "read_file": native_io.stdin_read_file
}